import os
import subprocess
try:
    from openff.toolkit import Molecule, Topology, ForceField
    from openff.interchange import Interchange
except ImportError:
    print("Warning: No openff found.")
from . import MATCHPATH, PERLPATH, MATCHEXE
from .cgenff_charmm2gmx_py3_nx2 import convert_match_charmm_to_gromacs

def wrap_match(inpath, outpath, tag, options={}):
    base_options = {"forcefield": "top_all36_cgenff_new"}
    base_options.update(options)
    env_dict={}
    if "PerlChemistry" in options and "MATCH" in options:
        env_dict = options["PerlChemistry"]
        env_dict = options["MATCH"]
    else:
        env_dict = {"PerlChemistry": PERLPATH, "MATCH": MATCHPATH}
    try:
        subprocess.run([MATCHEXE, "-forcefield", base_options["forcefield"], inpath], env=env_dict)
    except Exception as err:
        msg = "Excution of MATCH faild due to the following error."
        raise RuntimeError(msg) from err

    # to convert the MATCH file we need to create a combined str file
    str_file = f"{tag}.str"
    prm_lines = []
    rtf_lines = []
    with open(f"{tag}.rtf", "r") as _file:
        rtf_lines = _file.readlines()
    with open(f"{tag}.prm", "r") as _file:
        prm_lines = _file.readlines()
    
    header = """ Toppar stream file generated by
* CHARMM General Force Field (CGenFF) program version 2.5
* For use with CGenFF version 4.6
*

read rtf card append
* Topologies generated by
* CHARMM General Force Field (CGenFF) program version 2.5
*
36 1
"""
    record = False
    with open(f"{tag}.str", "w") as _file:
        _file.write(header)
        _file.write(f"RESI  {tag}  0.000000\n")
        _file.write("GROUP\n")
        for line in rtf_lines:
            if "GROUP" in line:
                record = True
            if record:
                _file.write(line)
        for line in prm_lines:
            _file.write(line)
        _file.write("\nEND\n")
        _file.write("RETURN")

    # we have to convert the charmm files to GROMACS
    convert_match_charmm_to_gromacs(tag,
                                    inpath,
                                    str_file,
                                    options['ffdir'])

def wrap_acpype(inpath, outpath, tag, options={}):
    base_options = ["-i", str(inpath), 
                    "-c", options.get("c", "abcg2"),
                    "-a", options.get("a", "gaff2"),
                    "-b", str(tag),
                    "-m", options.get("m", "1"),
                    "-n", options.get("c", "0")]
    try:
        cli = ["acpype"]+base_options
        # the API does not run correctly unfortunetly so we execute
        # it from the CLI
        subprocess.run(cli)
    except Exception as err:
        msg = "Excution of Acpype faild due to the following error."
        print(msg)
        print(err)
        #raise RuntimeError(msg) from err

def wrap_openff(inpath, outpath, tag, options={}):
    try:
        base_options = {"forcefield": "openff-2.0.0.offxml"}
        base_options.update(options)
        polymer = Molecule.from_file(inpath, file_format='sdf')
        topology = Topology.from_molecules([polymer])
        force_field = ForceField("openff-2.0.0.offxml")  # Let's stick to this one, although version 2.1.0 is also available
        interchange = Interchange.from_smirnoff(force_field, topology)
        openmm_system = interchange.to_openmm()
        openmm_topology = interchange.to_openmm_topology()
        openmm_positions = interchange.positions.to_openmm()
        # Output GROMACS files
        gromacs_filename_base = f'{outpath}/open_ff_polymer'
        interchange.to_gromacs(gromacs_filename_base)
    except Exception as err:
        print(err)
    
def wrap_ligpargen(inpath, outpath, tag, options={}):
    base_options = {"molname": "MOL",
                    "resname": "MOL",
                    "charge": 0,
                    "num_opts": 3,
                    "charge_method": "CM1A"}
    base_options.update(options)
    try:
        subprocess.run(["ligpargen", "-i", inpath, "-n", base_options["molname"],
                        "-p", outpath, "-r", base_options["resname"], 
                        "-c", base_options["charge"], "-o", base_options["num_opts"],
                        "-cgen", base_options["charge_method"]])
    except Exception as err:
        msg = "Excution of LigParGen faild due to the following error."
        raise RuntimeError(msg) from err

def wrap_grappa_amber(inpath, outpath, tag, options={}, run_acpype=True):
    if run_acpype:
        wrap_acpype(inpath, outpath, tag, options)
        inpath = f"{tag}.acpype/{tag}_GMX.top"
    # !grappa_gmx -t grappa-1.4.0 -f topol.top -o topol_grappa.top -p
    base_options = {"forcefield": "grappa-1.4.0"}
    base_options.update(options)
    try:
        subprocess.run(["grappa_gmx", "-t", base_options["forcefield"], "-f", inpath, "-o", f"{outpath}/grappa.top"])
    except Exception as err:
        msg = "Excution of GRAPPA faild due to the following error."
        raise RuntimeError(msg) from err


TOOL_REGISTRY = {"charmm36": wrap_match,
                 "gaff2": wrap_acpype,
                 "opls": wrap_ligpargen,
                 "grappa": wrap_grappa_amber, 
                 "openff": wrap_openff}
